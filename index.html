<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Gmail Viewer â€“ Threads & Timestamps</title>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 40px; background-color: #f4f7fa; color: #333; }
    h1 { text-align: center; margin-bottom: 10px; }
    #filterSection { text-align: center; margin-bottom: 30px; }
    #filterSection select, #searchInput, #searchButton {
      padding: 8px; font-size: 1em; margin: 0 5px;
    }
    #emails { list-style: none; padding: 0; max-width: 800px; margin: 0 auto; }
    #emails li {
      background: #fff; margin-bottom: 20px; padding: 20px;
      border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .subject {
      font-weight: 700; font-size: 1.1em; color: #004d99; cursor: pointer;
    }
    .subject.read { font-weight: normal; }
    .meta { font-size: 0.9em; color: #777; margin-bottom: 10px; }
    .email-body {
      margin-top: 10px; background: #f2f2f2;
      padding: 10px; border-radius: 5px; white-space: pre-wrap;
    }
    .thread-body {
      margin-top: 15px; padding-left: 15px; border-left: 3px solid #ccc;
    }
    .thread-container {
      display: none;
    }
    .reply-box {
      margin-top: 10px;
    }
    .reply-box input, .reply-box textarea {
      width: 100%; padding: 8px; margin-top: 5px;
      border-radius: 5px; border: 1px solid #ccc; font-size: 0.95em;
    }
    .reply-box textarea {
      height: 80px; resize: vertical;
    }
    .reply-box button {
      margin-top: 10px; padding: 8px 16px; border: none;
      border-radius: 5px; background-color: #0073e6; color: white;
      cursor: pointer; font-size: 0.95em; font-weight: 600; text-align: center;
    }
    .reply-box button:hover { background-color: #005bb5; }
    #backToTop {
      position: fixed; bottom: 20px; right: 20px; display: none;
      background-color: #0073e6; color: white; border: none;
      padding: 10px 20px; border-radius: 5px; cursor: pointer;
      font-weight: 600; text-align: center;
    }
    .new-badge {
      color: red; font-size: 0.9em; font-weight: bold; margin-left: 10px;
    }
  </style>
</head>
<body>
  <h1>My Gmail Inbox</h1>

  <!-- Sign-In -->
  <div id="g_id_onload"
       data-client_id="474892923870-2r0ksjol93ve88881n7p2glmv7onpd4l.apps.googleusercontent.com"
       data-context="use"
       data-ux_mode="popup"
       data-callback="handleCredentialResponse"
       data-auto_prompt="false"
       data-scope="https://www.googleapis.com/auth/gmail.modify"></div>

  <div class="g_id_signin"
       data-type="standard"
       data-shape="rectangular"
       data-theme="outline"
       data-text="signin_with"
       data-size="large"
       data-logo_alignment="left"></div>

  <!-- Filters -->
  <div id="filterSection">
    <label for="timeFilter">Time:</label>
    <select id="timeFilter" onchange="refreshInbox()">
      <option value="24h">Last 24 Hours</option>
      <option value="7d">Last 7 Days</option>
      <option value="all" selected>All</option>
    </select>

    <label for="labelFilter">Label:</label>
    <select id="labelFilter" onchange="refreshInbox()">
      <option value="label:INBOX">Inbox</option>
      <option value="label:SENT">Sent Mail</option>
      <option value="label:DRAFT">Drafts</option>
      <option value="label:SPAM">Junk / Spam</option>
      <option value="label:TRASH">Deleted Items</option>
    </select>

    <input type="text" id="searchInput" placeholder="Search keywords...">
    <button id="searchButton" onclick="refreshInbox()">Search</button>
  </div>
  <!-- Email List -->
  <ul id="emails"></ul>

  <!-- Back to Top Button -->
  <button id="backToTop" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">
    Back to Top
  </button>
<script>
  let access_token = '';
  let tokenClient;
  let nextPageToken = '';
  let lastMessageId = null;
  let loading = false;

  window.onload = function () {
    if (window.google && google.accounts) {
      initializeTokenClient();
    } else {
      setTimeout(() => {
        if (window.google && google.accounts) {
          initializeTokenClient();
        }
      }, 1000);
    }
  };

  function initializeTokenClient() {
    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: '474892923870-2r0ksjol93ve88881n7p2glmv7onpd4l.apps.googleusercontent.com',
      scope: 'https://www.googleapis.com/auth/gmail.modify',
      callback: (response) => {
        access_token = response.access_token;
        refreshInbox();
        setInterval(refreshInbox, 120000); // Refresh every 120 seconds
      },
    });
  }

  function handleCredentialResponse(response) {
    const decoded = JSON.parse(atob(response.credential.split('.')[1]));
    document.body.insertAdjacentHTML('afterbegin', `<p style='text-align:center;'>Welcome, ${decoded.name}</p>`);
    tokenClient?.requestAccessToken();
  }

  function formatDate(date) {
    return date.toLocaleString(undefined, {
      year: 'numeric', month: 'short', day: 'numeric',
      hour: '2-digit', minute: '2-digit'
    });
  }

  function getTimeQuery() {
    const timeFilter = document.getElementById('timeFilter').value;
    const labelFilter = document.getElementById('labelFilter').value;
    const searchTerm = document.getElementById('searchInput').value.trim();
    const now = new Date();
    const qParts = [];
    if (timeFilter === '24h') qParts.push('after:' + Math.floor((now.getTime() - 86400000) / 1000));
    if (timeFilter === '7d') qParts.push('after:' + Math.floor((now.getTime() - 604800000) / 1000));
    if (labelFilter) qParts.push(labelFilter);
    if (searchTerm) qParts.push(searchTerm);
    return qParts.join(' ');
  }

  function refreshInbox() {
    nextPageToken = '';
    document.getElementById('emails').innerHTML = '';
    loadInbox();
  }
function loadInbox() {
  if (loading) return;
  loading = true;

  const query = getTimeQuery();
  const url = new URL('https://gmail.googleapis.com/gmail/v1/users/me/threads');
  url.searchParams.set('maxResults', '10');
  if (query) url.searchParams.set('q', query);
  if (nextPageToken) url.searchParams.set('pageToken', nextPageToken);

  fetch(url, { headers: { 'Authorization': `Bearer ${access_token}` } })
    .then(res => res.json())
    .then(data => {
      loading = false;
      if (!data.threads) return;

      nextPageToken = data.nextPageToken || '';
      const list = document.getElementById('emails');

      // Sort threads by historyId (larger = more recent)
      const sortedThreads = data.threads.sort((a, b) => parseInt(b.historyId) - parseInt(a.historyId));

      sortedThreads.forEach(thread => {
        fetch(`https://gmail.googleapis.com/gmail/v1/users/me/threads/${thread.id}`, {
          headers: { 'Authorization': `Bearer ${access_token}` }
        })
          .then(res => res.json())
          .then(fullThread => {
            const item = document.createElement('li');
            const messages = fullThread.messages;
            const sortedMessages = messages.sort((a, b) => parseInt(b.internalDate) - parseInt(a.internalDate));
            const newestMsg = sortedMessages[0];
            const subject = newestMsg.payload.headers.find(h => h.name === 'Subject')?.value || '(No Subject)';
            const newestDate = formatDate(new Date(parseInt(newestMsg.internalDate)));
            const first = messages[0];
            const isUnread = first.labelIds?.includes("UNREAD");
            const newBadge = isUnread ? `<span class="new-badge">NEW</span>` : '';

            let threadHtml = '';
            sortedMessages.forEach(m => {
              const from = m.payload.headers.find(h => h.name === 'From')?.value || '(Unknown)';
              const date = formatDate(new Date(parseInt(m.internalDate)));
              const part = m.payload.parts?.find(p => p.mimeType === 'text/plain') || m.payload;
              const body = part.body.data ? atob(part.body.data.replace(/-/g, '+').replace(/_/g, '/')) : '(No body)';
              threadHtml += `
                <div class="thread-body">
                  <div class="meta">From: ${from}<br>Date: ${date}</div>
                  <div class="email-body">${body}</div>
                </div>`;
            });

            item.innerHTML = `
              <div class="subject${isUnread ? '' : ' read'}" onclick="toggleThread(this)">
                ${subject}${newBadge}
                <span style="float:right; font-size:0.85em; color:#666;">${newestDate}</span>
              </div>
              <div class="thread-container">
                ${threadHtml}
                <div class="reply-box">
                  <input type="text" class="cc" placeholder="CC (optional)">
                  <input type="text" class="bcc" placeholder="BCC (optional)">
                  <input type="file" class="attachment">
                  <textarea class="body" placeholder="Reply..."></textarea>
                  <button onclick="sendReply('${first.payload.headers.find(h => h.name === 'From')?.value}', '${subject}', this)">
                    Send Reply
                  </button>
                </div>
              </div>`;
            list.appendChild(item);
          });
      });
    });
}

  function toggleThread(subjectDiv) {
    const container = subjectDiv.nextElementSibling;
    const isHidden = container.style.display === 'none';
    container.style.display = isHidden ? 'block' : 'none';
    subjectDiv.classList.add('read');
    const badge = subjectDiv.querySelector('.new-badge');
    if (badge) badge.remove();
  }
  function sendReply(to, subject, button) {
    const box = button.closest('.reply-box');
    const cc = box.querySelector('.cc').value.trim();
    const bcc = box.querySelector('.bcc').value.trim();
    const body = box.querySelector('.body').value.trim();
    const fileInput = box.querySelector('.attachment');
    const file = fileInput.files[0];

    if (!body && !file) return alert('Reply must include a message or attachment.');

    const headers = [
      `To: ${to}`,
      `Subject: Re: ${subject}`,
      cc ? `Cc: ${cc}` : '',
      bcc ? `Bcc: ${bcc}` : '',
      'MIME-Version: 1.0',
      file ? 'Content-Type: multipart/mixed; boundary="boundary"' : 'Content-Type: text/plain; charset=UTF-8'
    ].filter(Boolean).join('\r\n');

    let mimeBody = '';

    if (file) {
      const reader = new FileReader();
      reader.onload = function () {
        const fileData = reader.result.split(',')[1];
        mimeBody = `--boundary
Content-Type: text/plain; charset="UTF-8"

${body}

--boundary
Content-Type: ${file.type}; name="${file.name}"
Content-Disposition: attachment; filename="${file.name}"
Content-Transfer-Encoding: base64

${fileData}
--boundary--`;

        const fullRaw = btoa(headers + '\r\n\r\n' + mimeBody).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        sendEmailRequest(fullRaw);
      };
      reader.readAsDataURL(file);
    } else {
      mimeBody = body;
      const fullRaw = btoa(headers + '\r\n\r\n' + mimeBody).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
      sendEmailRequest(fullRaw);
    }

    function sendEmailRequest(encoded) {
      fetch('https://gmail.googleapis.com/gmail/v1/users/me/messages/send', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${access_token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ raw: encoded })
      })
      .then(res => res.json())
      .then(() => {
        alert('Reply sent!');
        box.querySelector('.body').value = '';
        fileInput.value = '';
      })
      .catch(err => {
        console.error('Failed to send reply:', err);
        alert('Failed to send reply.');
      });
    }
  }

  window.onscroll = function () {
    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 50) {
      loadInbox();
    }
    document.getElementById('backToTop').style.display = window.scrollY > 300 ? 'block' : 'none';
  };
</script>
</body>
</html>
